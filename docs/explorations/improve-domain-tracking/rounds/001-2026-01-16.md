# Round 1 - 2026-01-16

## Issue 1: Multiple Chrome Profiles

### 1.1 Profile Selection Strategy

How should users configure which profiles to track?

**Options:**
a) Settings UI with checkboxes for each discovered profile
b) Include/exclude list by profile name in settings
c) Auto-detect "work" profiles based on heuristics (e.g., signed-in Google account domain)
d) Simple toggle: "Track all profiles" vs "Track Default only"

**Your answer:**
a

---

### 1.2 Profile Identification

I found these profiles on your system:
- `Default` (the main profile)
- `Profile 1`
- `Profile 2`
- `Guest Profile`

Which ones are work profiles and which is personal? This helps me understand your use case.

**Your answer:**
It is hard to identify profiles by these identifiers ('Default', ' Profile 1', 'Profile 2'). Can you see if you can find display names ('feed.no', 'netlife.com','Svale')  or email ?

---

### 1.3 Profile Name Display

Chrome profiles have internal names (Default, Profile 1, etc.) but also display names you set (e.g., "Work - Company A"). Should we:

a) Show internal names (simpler, always consistent)
b) Read and show display names from Chrome's Preferences file (more user-friendly)
c) Let users rename them in our settings

**Your answer:**
B

---

## Issue 2: Over-tracking / Ghost Time

### 2.1 What does "accurate" mean to you?

When you see "2 hours on github.com today", what should that represent?

a) Time with github.com as the **active/focused** tab
b) Time with github.com **open** (even if backgrounded)
c) Sum of individual page view durations on github.com
d) Something else?

**Your answer:**
A

---

### 2.2 Acceptable Accuracy Trade-offs

More accurate time tracking typically requires more invasive approaches. Rank these by acceptability:

1. **Current approach**: Browser history only, no permissions needed
   - Accuracy: Low (counts all visits, even background tabs)

2. **Browser extension**: Could track active tab only
   - Accuracy: High for Chrome/Safari with extension installed
   - Trade-off: Requires installing extension, more moving parts

3. **Active window monitoring**: Use macOS APIs to detect frontmost app/window
   - Accuracy: Medium-High (knows when browser is focused)
   - Trade-off: Requires accessibility permission (you explicitly don't want this)

4. **Hybrid**: Combine browser history with simple "is browser frontmost" check
   - Could use `osascript` to check without accessibility permission

5. **Heuristics**: Improve session aggregation logic
   - Example: Cap max session duration, discount overlapping domains, weight by visit frequency

**Your answer:**
4 (hybrid) and enhanced with 5 (Heuristics) if any low hanging fruits

---

### 2.3 Session Duration Problem

Currently, if you visit:
- github.com at 9:00
- stackoverflow.com at 9:15
- github.com at 9:20
- github.com at 9:25

We create a session for each domain based on consecutive visits. The github.com visits at 9:20 and 9:25 become a session with ~5 minute duration.

**Problem**: What if you had github.com open in a background tab the whole time and were actually working in VS Code?

How should we handle this? Options:
a) Accept it as a limitation (browser history can't know focus)
b) Cap maximum session duration (e.g., 30 min max per session)
c) Use visit count as a weight factor (more visits = more likely active)
d) Discount "refresh" patterns (same URL repeatedly = likely background auto-refresh)
e) Other approach?

**Your answer:**
I think a combination of B and C. Also take into account how this works with "is browser in forcus"-check

---

### 2.4 Chrome's visit_duration Field

Chrome stores `visit_duration` in microseconds. Initial research suggests this measures time until the next navigation in that tab, not necessarily active viewing time.

Should I research this more deeply to understand exactly what it measures and whether we can use it better?

**Your answer:**


---

## Implementation Priority

### 2.5 Which issue should we tackle first?

a) Profile support (clear scope, straightforward implementation)
b) Over-tracking improvements (more impactful but more complex)
c) Both in parallel (different parts of the codebase)

**Your answer:**
Lets begin with a) and complete this. Then move on to b

---
